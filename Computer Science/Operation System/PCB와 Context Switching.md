## PCB와 Context Switching

🕹 다시 한번 짚고 넘아가자!
```
하나의 cpu는(1 코어) 하나의 task만 수행할 수 있다.
```

#### Context Swithching 이란 무엇일까?
![image](https://user-images.githubusercontent.com/58067265/123517290-2319b000-d6db-11eb-9ff3-e2d53c315c8f.png)
```
멀티프로세스/멀티스레드 환경일때, cpu가 task(프로세스/스레드)를 실행하고 있는 상태에서 인터럽트 요청에 의해 다음 우선순위의 Task가 실행되어야 한다.
이때 기존의 Task상태 또는 레지스터 값을 교체하는 그 순간을 말한다.
```

#### PCB란 무엇일까?

컨텍스트를 스위칭하기 위해서는 각 프로세스/스레드의 상태를 알아야 한다.
그리고 스위칭하기 위해서는 어떤 프로세스/스레드를 어디까지 진행했는지 여부도 알아야 한다.

```
프로세스를 제어하기 위한 정보의 모음을 말한다. 프로세스가 생성될 때 pcb가 만들어져 각 프로세스는 고유의 PCB를 갖는다. (스레드는 TCB)
```

#### PCB가 어떤 정보를 저장하고 있을까?

![image](https://user-images.githubusercontent.com/58067265/123518871-e2be3000-d6e2-11eb-98af-64c6c07c10dc.png)

* 프로세스 고유 번호
* 프로세스 상태
  * create 
  * ready
  * waiting
  * running
  * terminated
* 포인터 = 다음 실행될 프로세스의 포인터
* program counter = 다음에 실행할 명령어의 주소
* 레지스터
* cpu 스케쥴링 정보 = 우선순위, 최종 실행 시각, cpu 점유 시간
* 메모리 관리 정보 = 해당 프로세스의 주소 공간
* 프로세스 계정 정보
* 입출력 상태 정보 = 프로세스에 할당된 입출력장치 목록, 열린 파일 목록

#### 언제 Context Switching이 일어날까?
![image](https://user-images.githubusercontent.com/58067265/123519245-008c9480-d6e5-11eb-957f-ab820aee7c12.png)

* 프로세스 상태
 * 생성 = 프로세스를 생성하고 있는 단계 (이때 커널 공간에 pcb가 만들어짐)
 * 준비 = 프로세스가 cpu를 기다리는 상태 (메모리에 적재되기 이전의 상태로 필요한 자원을 모두 얻은 상태)
 * blocked = 프로세스가 cpu를 할당 받아도 당장 실행할 수 없는 상태 (자신이 요청한 i/o가 만족되지 않아 기다리는 상태)
 * terminated = 프로세스 실행 종료로 cpu 반납
 * suspended = 프로세스 중지 상태 

```
1) 인터럽트 발생 시 (Interrupt)
2) 실행중인 cpu 사용 할당을 모두 소모했을 때 (schedular dispatch)
3) 입출력을 위해 대기할 때 (I/O or Event wait)
4) 자식 프로세스를 만들 때
```

#### 어떻게 진행이 될까?
![image](https://user-images.githubusercontent.com/58067265/123520003-7bf04500-d6e9-11eb-9925-b03dfb8ee384.png)

1) cpu에서 다른 프로세스로 전환 시, 기존 동작 중인 프로세스 상태를 pcb에 저장
2) 대기열에서 다음 프로세스를 선택하고 해당 pcb를 레지스터에 적재
3) 프로그램 카운터가 로드되어 해당 프로세스의 다음 동작 진행

#### 오버헤드란?
```
컨텍스트 스위칭에 걸린 시간과 메모리(프로세스를 처리하기 위해 들어가는 간접적인 처리 시간/메모리로 이것을 줄여야 좋다!) 
```
프로세스 작업 중에 오버헤드를 감수해야 하는 상황을 말했다.
대기 상태로 전환시켰을 때 cpu를 놀게 놔두는 것보다 오버헤드가 있더라도 다른 프로세스를 수행시키는게 좋다.



#### 멀티프로세스 vs 멀티스레드의 오버헤드
os의 스케쥴러가 스케쥴링해주는 것이 pcb이고 프로세스에 있는 스레드 라이브러리에 의해 스케쥴링 되는 것이 tcb이다.  
n process 로 하나의 작업 수행 vs n thread 로 하나의 작업 수행 의 관점에서 비교해보자.

![image](https://user-images.githubusercontent.com/58067265/123532180-05cdfb80-d746-11eb-9fa9-9a699aa53ae9.png)

프로세스와 스레드이 메모리 구조에 의해 pcs가 일어날 때, 캐시가 플러시되지만 tcs가 일어나는 경우 유지된다.그로인해 pcb를 변경하는데 더 많은 비용이 소모된다.

#### 추가로 알면 도움이 될 키워드
* 레지스터

## 출처
https://thebook.io/006950/ch10/01/03-01/  
https://www.crocus.co.kr/1364  








